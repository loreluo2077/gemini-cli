# Gemini Core Tools 文档

本文档概述了 Gemini CLI 的核心工具，这些工具为模型提供了与本地文件系统和 shell
环境交互的能力。

## 1. `replace` (`edit.ts`)

- **用途:** 在文件中替换文本。它既可以替换单个匹配项，也可以替换多个匹配项。
- **核心原理:**
  - **精确匹配:** 要求在 `old_string`
    中提供大量上下文（通常是目标文本前后各三行），以确保替换的精确性，避免意外修改。
  - **智能校正:** 在应用更改之前，可能会利用 LLM
    来微调要查找和替换的文本，以处理微小的格式差异，提高成功率。
  - **文件创建:** 如果文件不存在且 `old_string` 为空，则会创建一个新文件。
  - **用户确认:**
    在执行写入操作前，会生成一个差异（diff）并要求用户确认，以防止不必要的更改。

## 2. `glob` (`glob.ts`)

- **用途:** 根据 "glob" 模式（如 `src/**/*.ts`）高效地查找文件。
- **核心原理:**
  - **模式匹配:** 使用 `glob` 库在指定目录中进行文件搜索。
  - **Git 集成:** 默认情况下，它会读取 `.gitignore` 文件并排除被忽略的文件。
  - **智能排序:**
    搜索结果会优先显示最近修改过的文件，这有助于模型快速找到相关的最新工作。

## 3. `search_file_content` (`grep.ts`)

- **用途:** 在文件内容中搜索正则表达式模式。
- **核心原理:**
  - **智能后端选择:**
    1. **`ripgrep` (`rg`):** 如果可用，则优先使用，因为它速度极快且内置了对
       `.gitignore` 的支持。
    2. **`git grep`:** 如果在 Git 仓库中且 `rg` 不可用，则使用它。
    3. **Node.js 回退:** 如果以上两者都不可用，则使用纯 Node.js 实现。
  - **灵活搜索:** 允许通过 `include` 参数将搜索范围限定在特定的文件类型中。

## 4. `list_directory` (`ls.ts`)

- **用途:** 列出指定目录中的文件和子目录。
- **核心原理:**
  - **路径验证:** 确保指定的路径是绝对路径并且位于项目的工作区内。
  - **Git 集成:** 与 `glob` 工具类似，它默认会尊重 `.gitignore`
    规则，不显示被忽略的文件。
  - **清晰的输出:**
    输出结果会清晰地标识出条目是文件还是目录，并按字母顺序排序（目录优先）。

## 5. `read_file` (`read-file.ts`)

- **用途:** 读取文件的内容。支持文本、多种图片格式和 PDF。
- **核心原理:**
  - **多格式支持:** 能够处理不同类型的文件，并以适当的格式返回其内容。
  - **分页:** 对于大型文本文件，支持通过 `offset` 和 `limit` 参数进行分块读取。
  - **安全检查:** 确保要读取的文件位于项目工作区内，并且没有被 `.geminiignore`
    规则排除。

## 6. `write_file` (`write-file.ts`)

- **用途:** 将内容写入文件。如果文件已存在则覆盖，不存在则创建。
- **核心原理:**
  - **智能内容校正:** 在写入之前，可能会利用 LLM
    根据文件的上下文来"修正"要写入的内容，以确保代码风格的一致性和正确性。
  - **用户确认:** 与 `replace`
    工具一样，在写入前会生成一个差异（diff）并要求用户确认，这是防止 AI
    意外破坏代码的关键安全功能。
  - **目录创建:** 如果目标文件的父目录不存在，会自动创建。

## 7. `run_shell_command` (`shell.ts`)

- **用途:** 执行任意 shell 命令。
- **核心原理:**
  - **安全第一:**
    - **确认机制:** 在执行任何命令之前，必须得到用户的明确批准。
    - **白名单:** 用户可以选择"始终允许"某个命令的根（如
      `npm`），之后该命令的执行将不再需要重复确认。
  - **后台进程:** 支持执行后台命令，并能正确地管理这些进程。
  - **取消支持:** 如果用户取消操作，它会尝试终止正在运行的命令及其所有子进程。

## 8. `web_fetch` (`web-fetch.ts`)

- **用途:** 获取并处理一个或多个 URL
  的内容。它非常灵活，可以处理公共网站、`localhost` 以及私有网络地址。
- **核心原理:**
  - **原生处理:** 对于公共 URL，优先使用 Gemini API 的原生 `urlContext` 功能，让
    Google 的后端来处理内容的获取和解析。
  - **后备机制:** 对于本地或私有 URL，或者当原生获取失败时，CLI 会直接发起
    `fetch` 请求，将获取到的 HTML 内容转换为纯文本，然后再交给 LLM 处理。
  - **GitHub 智能转换:** 能自动将 GitHub 的 `blob` 链接转换为可直接访问的 `raw`
    文件链接。

## 9. `google_web_search` (`web-search.ts`)

- **用途:** 使用 Google 搜索执行 Web 搜索，以获取模型知识库之外的最新信息。
- **核心原理:**
  - **API 驱动:** 该工具调用 Gemini API 内置的 `googleSearch` 功能，由 Google
    的后端执行实际的搜索操作。
  - **来源引用:**
    它不仅返回搜索结果的摘要文本，还会处理返回的元数据，在文本中插入对信息来源的引用标记（如
    `[1]`），并在末尾附上完整的来源 URL 列表，保证了信息的可追溯性。

## 10. MCP 工具 (`mcp-client.ts` & `mcp-tool.ts`)

- **用途:** 实现了一个插件系统，允许 Gemini CLI
  动态地发现和使用在外部服务器或进程上运行的工具。MCP 指的是**模型-上下文协议
  (Model-Context Protocol)**。
- **核心原理:**
  - **发现与连接:** CLI 可以通过多种方式（如启动子进程、连接到 HTTP
    端点）连接到外部的 MCP 工具服务器。
  - **动态代理:** 连接成功后，外部服务器上的工具会被注册到 CLI 中。当 LLM
    调用这些工具时，CLI 会作为代理，将请求转发给外部服务器执行，并将结果返回给
    LLM。
  - **信任与确认:** 与 `shell`
    工具类似，调用来自未受信任服务器的工具前需要用户确认，用户也可以选择信任某个工具或整个服务器以简化后续操作。

## 11. `save_memory` (`memoryTool.ts`)

- **用途:** 将特定的信息片段保存到长期记忆中，以便在未来的会话中使用。
- **核心原理:**
  - **基于文件的记忆:** "记忆"被持久化地存储在一个 Markdown 文件中（默认为
    `~/.gemini/GEMINI.md`）。
  - **追加式写入:** 当需要"记住"新信息时，该工具会读取这个文件，找到一个特定的
    `## Gemini Added Memories` 标题，然后将新信息作为列表项追加到该区域。
  - **上下文注入:** 这个 Markdown 文件的内容会在会话开始时作为上下文提供给
    LLM，从而让模型能够"记起"之前保存过的事实。
