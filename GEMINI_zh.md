## 构建和运行

在提交任何更改之前，通过运行完整的预检检查来验证它们是至关重要的。此命令将构建仓库、运行所有测试、检查类型错误并检查代码。

要运行完整的检查套件，请执行以下命令：

```bash
npm run preflight
```

这个单一命令确保您的更改满足项目的所有质量标准。虽然您可以单独运行各个步骤（`build`、`test`、`typecheck`、`lint`），但强烈建议使用
`npm run preflight` 来确保全面验证。

## 编写测试

此项目使用 **Vitest**
作为主要测试框架。编写测试时，力求遵循现有模式。主要约定包括：

### 测试结构和框架

- **框架**：所有测试都使用 Vitest（`describe`、`it`、`expect`、`vi`）编写。
- **文件位置**：测试文件（逻辑测试用 `*.test.ts`，React 组件测试用
  `*.test.tsx`）与它们测试的源文件共同定位。
- **配置**：测试环境在 `vitest.config.ts` 文件中定义。
- **设置/清理**：使用 `beforeEach` 和 `afterEach`。通常在 `beforeEach` 中调用
  `vi.resetAllMocks()`，在 `afterEach` 中调用 `vi.restoreAllMocks()`。

### 模拟（Vitest 的 `vi`）

- **ES 模块**：使用 `vi.mock('module-name', async (importOriginal) => { ... })`
  进行模拟。使用 `importOriginal` 进行选择性模拟。
  - _示例_：`vi.mock('os', async (importOriginal) => { const actual = await importOriginal(); return { ...actual, homedir: vi.fn() }; });`
- **模拟顺序**：对于影响模块级常量的关键依赖（如 `os`、`fs`），将 `vi.mock`
  放在测试文件的_最顶部_，在其他导入之前。
- **提升**：如果需要在 `vi.mock` 工厂中使用之前定义模拟函数，请使用
  `const myMock = vi.hoisted(() => vi.fn());`。
- **模拟函数**：使用 `vi.fn()` 创建。使用
  `mockImplementation()`、`mockResolvedValue()` 或 `mockRejectedValue()`
  定义行为。
- **监听**：使用 `vi.spyOn(object, 'methodName')`。在 `afterEach` 中使用
  `mockRestore()` 恢复监听。

### 常用模拟模块

- **Node.js 内置模块**：`fs`、`fs/promises`、`os`（特别是
  `os.homedir()`）、`path`、`child_process`（`execSync`、`spawn`）。
- **外部 SDK**：`@google/genai`、`@modelcontextprotocol/sdk`。
- **内部项目模块**：来自其他项目包的依赖通常被模拟。

### React 组件测试（CLI UI - Ink）

- 使用 `ink-testing-library` 的 `render()`。
- 使用 `lastFrame()` 断言输出。
- 在必要的 `Context.Provider` 中包装组件。
- 使用 `vi.mock()` 模拟自定义 React 钩子和复杂的子组件。

### 异步测试

- 使用 `async/await`。
- 对于计时器，使用
  `vi.useFakeTimers()`、`vi.advanceTimersByTimeAsync()`、`vi.runAllTimersAsync()`。
- 使用 `await expect(promise).rejects.toThrow(...)` 测试 promise 拒绝。

### 一般指导

- 添加测试时，首先检查现有测试以了解并遵循已建立的约定。
- 特别注意现有测试文件顶部的模拟；它们揭示了关键依赖以及它们在测试环境中的管理方式。

## Git 仓库

此项目的主分支称为"main"

## JavaScript/TypeScript

在为这个 React、Node 和 TypeScript 代码库做贡献时，请优先使用带有相应 TypeScript
接口或类型声明的纯 JavaScript 对象，而不是 JavaScript
类语法。这种方法提供了显著的优势，特别是在与 React
的互操作性和整体代码可维护性方面。

### 优先使用纯对象而非类

JavaScript
类天生设计用于封装内部状态和行为。虽然这在某些面向对象的范式中可能有用，但在使用
React
基于组件的架构时，它经常引入不必要的复杂性和摩擦。以下是优先使用纯对象的原因：

- 无缝 React 集成：React 组件在显式 props
  和状态管理上蓬勃发展。类在实例内直接存储内部状态的倾向可能使 props
  和状态传播更难推理和维护。另一方面，纯对象本质上是不可变的（在深思熟虑地使用时），可以轻松作为
  props 传递，简化数据流并减少意外的副作用。

- 减少样板代码并增加简洁性：类经常促进构造函数、this 绑定、getter、setter
  和其他样板代码的使用，这些可能不必要地膨胀代码。TypeScript
  接口和类型声明提供强大的静态类型检查，而没有类定义的运行时开销或冗长性。这允许更简洁和可读的代码，与
  JavaScript 在函数式编程中的优势保持一致。

- 增强可读性和可预测性：纯对象，特别是当它们的结构由 TypeScript
  接口清楚定义时，通常更容易阅读和理解。它们的属性是直接可访问的，没有隐藏的内部状态或复杂的继承链需要导航。这种可预测性导致更少的错误和更可维护的代码库。

- 简化不可变性：虽然不是严格强制的，纯对象鼓励数据的不可变方法。当您需要修改对象时，您通常创建一个具有所需更改的新对象，而不是改变原始对象。这种模式与
  React 的协调过程完美匹配，并有助于防止与共享可变状态相关的细微错误。

- 更好的序列化和反序列化：纯 JavaScript 对象自然容易序列化为 JSON
  并反序列化回来，这是 Web 开发中的常见需求（例如，用于 API
  通信或本地存储）。具有方法和原型的类可能使此过程复杂化。

### 拥抱 ES 模块语法进行封装

我们强烈倾向于利用 ES 模块语法（`import`/`export`）来封装私有和公共
API，而不是依赖可能冗长且有时限制灵活性的类似 Java 的私有或公共类成员。

- 更清晰的公共 API 定义：使用 ES 模块，任何导出的内容都是该模块公共 API
  的一部分，而任何未导出的内容本质上对该模块是私有的。这提供了一种非常清晰和明确的方式来定义代码的哪些部分旨在被其他模块使用。

- 增强可测试性（不暴露内部结构）：默认情况下，未导出的函数或变量不能从模块外部访问。这鼓励您测试模块的公共
  API，而不是它们的内部实现细节。如果您发现自己需要为测试目的监听或存根未导出的函数，这通常是一个"代码异味"，表明该函数可能是提取到自己的独立、可测试模块中的良好候选，具有明确定义的公共
  API。这促进了更强大和可维护的测试策略。

- 减少耦合：通过 import/export
  明确定义的模块边界有助于减少代码库不同部分之间的耦合。这使得独立重构、调试和理解各个组件变得更容易。

### 避免 `any` 类型和类型断言；偏好 `unknown`

TypeScript
的力量在于其提供静态类型检查的能力，在代码运行之前捕获潜在错误。要充分利用这一点，避免使用
`any` 类型并谨慎使用类型断言是至关重要的。

- **`any` 的危险**：使用 any 实际上选择退出了 TypeScript
  对特定变量或表达式的类型检查。虽然在短期内可能看起来方便，但它引入了重大风险：

  - **失去类型安全**：您失去了类型检查的所有好处，使得容易引入 TypeScript
    本来会捕获的运行时错误。
  - **降低可读性和可维护性**：具有 `any`
    类型的代码更难理解和维护，因为预期的数据类型不再明确定义。
  - **掩盖潜在问题**：通常，对 any
    的需求表明代码设计或与外部库交互方式存在更深层的问题。这是一个信号，您可能需要改进类型或重构代码。

- **偏好 `unknown` 而非
  `any`**：当您绝对无法在编译时确定值的类型，并且被诱惑使用 any 时，请考虑使用
  unknown。unknown 是 any 的类型安全对应物。虽然 unknown
  类型的变量可以保存任何值，但您必须在对其执行任何操作之前执行类型缩小（例如，使用
  typeof 或 instanceof 检查，或类型断言）。这迫使您明确处理 unknown
  类型，防止意外的运行时错误。

  ```
  function processValue(value: unknown) {
     if (typeof value === 'string') {
        // value 现在安全地是字符串
        console.log(value.toUpperCase());
     } else if (typeof value === 'number') {
        // value 现在安全地是数字
        console.log(value * 2);
     }
     // 没有缩小，您无法访问 'value' 上的属性或方法
     // console.log(value.someProperty); // 错误：对象是 'unknown' 类型。
  }
  ```

- **类型断言（`as Type`）- 谨慎使用**：类型断言告诉 TypeScript
  编译器，"相信我，我知道我在做什么；这绝对是这种类型。"虽然有合法的用例（例如，在处理没有完美类型定义的外部库时，或当您比编译器拥有更多信息时），但应该谨慎使用并极其小心。
  - **绕过类型检查**：像 `any` 一样，类型断言绕过 TypeScript
    的安全检查。如果您的断言不正确，您会引入 TypeScript 不会警告您的运行时错误。
  - **测试中的代码异味**：在测试中可能诱使您使用 `any`
    或类型断言的常见场景是尝试测试"私有"实现细节（例如，监听或存根模块内的未导出函数）。这强烈表明您的测试策略和可能的代码结构存在"代码异味"。与其试图强制访问私有内部结构，不如考虑这些内部细节是否应该重构为具有明确定义的公共
    API 的独立模块。这使它们在不损害封装的情况下本质上可测试。

### 拥抱 JavaScript 的数组操作符

为了进一步增强代码清洁度并促进安全的函数式编程实践，尽可能利用 JavaScript
丰富的数组操作符集合。像
`.map()`、`.filter()`、`.reduce()`、`.slice()`、`.sort()`
等方法在以不可变和声明性的方式转换和操作数据集合方面非常强大。

使用这些操作符：

- 促进不可变性：大多数数组操作符返回新数组，保持原始数组不变。这种函数式方法有助于防止意外的副作用，使您的代码更可预测。
- 提高可读性：链式数组操作符通常比传统的 for
  循环或命令式逻辑产生更简洁和表达性的代码。操作的意图一目了然。
- 促进函数式编程：这些操作符是函数式编程的基石，鼓励创建接受输入并产生输出而不引起副作用的纯函数。这种范式对于编写与
  React 良好配对的强大和可测试代码非常有益。

通过一致地应用这些原则，我们可以维护一个不仅高效和高性能，而且现在和将来都令人愉快的代码库。

## React（从 [react-mcp-server](https://github.com/facebook/react/blob/4448b18760d867f9e009e810571e7a3b8930bb19/compiler/packages/react-mcp-server/src/index.ts#L376C1-L441C94) 镜像和调整）

### 角色

您是一个 React 助手，帮助用户编写更高效和可优化的 React 代码。您专门识别使 React
编译器能够自动应用优化的模式，减少不必要的重新渲染并提高应用程序性能。

### 在您生成和建议的所有代码中遵循这些指导原则

使用带有 Hooks 的函数组件：不要生成类组件或使用旧的生命周期方法。使用 useState
或 useReducer 管理状态，使用 useEffect（或相关
Hooks）管理副作用。总是为任何新的组件逻辑优先选择函数和 Hooks。

在渲染过程中保持组件纯净和无副作用：不要生成在组件函数体内直接执行副作用（如订阅、网络请求或修改外部变量）的代码。这些操作应该包装在
useEffect 中或在事件处理程序中执行。确保您的渲染逻辑是 props 和状态的纯函数。

尊重单向数据流：通过 props
向下传递数据，避免任何全局变更。如果两个组件需要共享数据，将该状态提升到共同的父组件或使用
React Context，而不是试图同步本地状态或使用外部变量。

永远不要直接变更状态：总是生成不可变地更新状态的代码。例如，在更新状态时使用展开语法或其他方法创建新的对象/数组。不要在状态变量上使用像
state.someValue = ... 或 array.push()
这样的赋值或数组变更。使用状态设置器（useState 的 setState 等）更新状态。

准确使用 useEffect 和其他效果 Hooks：每当您认为可以使用 useEffect
时，请更深入地思考和推理以避免它。useEffect 主要仅用于同步，例如将 React
与某些外部状态同步。重要 - 不要在 useEffect 内设置状态（useState
返回的第二个值），因为这会降低性能。编写效果时，在依赖数组中包含所有必要的依赖。不要抑制
ESLint 规则或省略效果代码使用的依赖。构建效果回调以正确处理变化的值（例如，在
prop
变化时更新订阅，在卸载或依赖变化时清理）。如果一段逻辑应该只响应用户操作（如表单提交或按钮点击）运行，将该逻辑放在事件处理程序中，而不是在
useEffect 中。在可能的情况下，useEffects 应该返回清理函数。

遵循 Hooks 规则：确保任何 Hooks（useState、useEffect、useContext、自定义 Hooks
等）在 React 函数组件或其他 Hooks
的顶层无条件调用。不要生成在循环、条件语句或嵌套辅助函数内调用 Hooks
的代码。不要在非组件函数或 React 组件渲染上下文之外调用 Hooks。

仅在必要时使用 refs：除非任务真正需要（如聚焦控件、管理动画或与非 React
库集成），否则避免使用 useRef。不要使用 refs
存储应该响应的应用程序状态。如果您确实使用
refs，永远不要在组件渲染期间写入或读取
ref.current（除了像懒初始化这样的初始设置）。任何 ref
使用都不应该直接影响渲染输出。

偏好组合和小组件：将 UI
分解为小的、可重用的组件，而不是编写大的单体组件。您生成的代码应该通过将组件组合在一起来促进清晰度和可重用性。类似地，在适当时将重复逻辑抽象为自定义
Hooks，以避免重复代码。

为并发优化：假设 React
可能出于调度目的多次渲染您的组件（特别是在使用严格模式的开发中）。编写即使组件函数运行多次也保持正确的代码。例如，避免在组件体中产生副作用，并在基于先前状态更新状态时使用函数状态更新（例如，setCount(c
=> c +
1)）以防止竞争条件。总是在订阅外部资源的效果中包含清理函数。不要为"当这个改变时做这个"副作用编写
useEffects。这确保您生成的代码将与 React 的并发渲染功能一起工作而不会出现问题。

优化以减少网络瀑布 -
尽可能使用并行数据获取（例如，立即开始多个请求而不是一个接一个）。利用 Suspense
进行数据加载，并保持请求与需要数据的组件共同定位。在以服务器为中心的方法中，在服务器端一起获取相关数据（例如，使用服务器组件）以减少往返次数。此外，考虑使用缓存层或全局获取管理来避免重复相同的请求。

依赖 React 编译器 - 如果启用了 React 编译器，可以省略 useMemo、useCallback 和
React.memo。避免手动记忆化的过早优化。相反，专注于编写具有直接数据流和无副作用渲染函数的清晰、简单组件。让
React 编译器处理树摇、内联和其他性能增强，以保持代码库更简单和更可维护。

为良好的用户体验设计 - 提供清晰、最小和非阻塞的 UI
状态。当数据加载时，显示轻量级占位符（例如，骨架屏幕）而不是到处都是侵入性的旋转器。使用专用的错误边界或友好的内联消息优雅地处理错误。在可能的情况下，渲染部分数据，而不是让用户等待所有内容。Suspense
允许您以自然的方式在组件树中声明加载状态，防止"闪烁"状态并改善感知性能。

### 过程

1. 分析用户代码的优化机会：

   - 检查阻止编译器优化的 React 反模式
   - 寻找限制编译器有效性的组件结构问题
   - 思考您提出的每个建议并咨询 React 文档的最佳实践

2. 提供可行的指导：
   - 用清晰的推理解释具体的代码更改
   - 在建议更改时显示前后示例
   - 只建议有意义地改善优化潜力的更改

### 优化指导原则

- 状态更新应该结构化以启用粒度更新
- 副作用应该被隔离，依赖明确定义

## 注释政策

只有在确实有高价值时才写注释。避免通过注释与用户交谈。
